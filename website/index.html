<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8"/>
    <meta name="description"    content="Data Visualization"/>
    <meta name="keywords"       content="HTML, CSS, D3"/>
    <meta name="author"         content=""/>
    <title>Assignment</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>

    </style>
</head>
<body>
    <p id="globe">
        <p id="sliderValue">XXXX</p>
        <input type="range", class="slider", id="yearSlider">
        <br/>
        <svg id="globesvg"></svg>
        <script>
            // setup variables
            var w = 660;
            var h = 450;
            var dataset;
            var selectedYear;
            var colourRange;
            var values = [,];
            var svg = d3.select("#globesvg")
                    .attr("width", w)
                    .attr("height", h)
                    .attr("fill", "grey")
                    .attr("style", "background-color:LightSkyBlue");;
            var projection = d3.geoMercator()
                .center([0, 0])
                .translate([w/2, (h/3)*2])
                .scale(100);
            var path = d3.geoPath()
                .projection(projection);
            // #########
            // FUNCTIONS
            // #########
            // gets the data and returns in the form of a promise
            function GetData() {
                result = d3.csv("Data/DS_Tobacco.csv").then(function(d) {
                    dataset = d;
                    return dataset;
                });
                return result;
            };
            // DateChanged function
            // called when the date is changed
            async function DateChanged() {
                values = [,]
                console.log("start DateChange");
                GetData().then(function(data) {
                    d3.json("globe.geo.json").then(function(json) {
                        // loop through the dataset
                        for (var i = 0; i < dataset.length; i++){
                            // get value and referencearea from dataset
                            dataRef = dataset[i].ReferenceArea;
                            dataDate = parseInt(dataset[i].TIME_PERIOD);
                            dataValue = parseInt(dataset[i].OBS_VALUE);
                            // check that date is the selected date
                            if (dataDate <= selectedYear) {
                                // loop through the geoJSON
                                for (var j = 0; j < json.features.length; j++){
                                    // get reference area from json
                                    jsonRef = json.features[j].properties.name_long;
                                    if (values[j, 1] == undefined){
                                        if (dataRef == jsonRef) {
                                            values[j,0] = dataValue;
                                            values[j,1] = dataDate;
                                            break;
                                        }
                                    }
                                    else
                                    {
                                        if (dataRef == jsonRef && (
                                            dataDate > values[j,1]
                                            )) {
                                            values[j,0] = dataValue;
                                            values[j,1] = dataDate;
                                            break;
                                        }
                                    };
                                };
                            };
                        };
                        update(json)
                    });
                });
            };
            // Load() function
            // run once on initial start
            async function Load() {
                console.log("start Load");
                GetData().then(function(data){
                    // set min and max of scale
                    d3.select("#yearSlider")
                        .attr("max", d3.max(data, function(d){return d.TIME_PERIOD}))
                        .attr("min", d3.min(data, function(d){return d.TIME_PERIOD}))
                        .on("input", function(d)
                        {
                            selectedYear = this.value;
                            d3.select("#sliderValue").text(selectedYear);
                            DateChanged()
                        });
                    // set initial value of selected year
                    selectedYear = d3.select("#yearSlider").attr("min");
                    d3.select("#sliderValue").text(selectedYear);
                    // initialize colour range
                    colourRange = d3.scaleQuantize()
                        .domain([0, d3.max(dataset, function(dataset){return dataset.OBS_VALUE;}) ])
                        .range(["rgb(241,238,246)",
                            "rgb(215,181,216)",
                            "rgb(223,101,176)",
                            "rgb(221,28,119)",
                            "rgb(152,0,67)"]);
                    // load geoJSON
                    d3.json("globe.geo.json").then(function(json) {
                        // loop through the dataset
                        for (var i = 0; i < dataset.length; i++){
                            // get value and referencearea from dataset
                            dataRef = dataset[i].ReferenceArea
                            dataDate = parseInt(dataset[i].TIME_PERIOD)
                            dataValue = parseInt(dataset[i].OBS_VALUE)
                            // check that date is the selected date
                            if (dataDate <= selectedYear) {
                                // loop through the geoJSON
                                for (var j = 0; j < json.features.length; j++){
                                    // get reference area from json
                                    jsonRef = json.features[j].properties.name_long;
                                    if (values[j, 1] == undefined){
                                        if (dataRef == jsonRef) {
                                            values[j,0] = dataValue;
                                            values[j,1] = dataDate;
                                            break;
                                        }
                                    }
                                    else
                                    {
                                        if (dataRef == jsonRef && (
                                            dataDate > values[j,1]
                                            )) {
                                            values[j,0] = dataValue;
                                            values[j,1] = dataDate;
                                            break;
                                        }
                                    };
                                };
                            };
                        }
                    update(json)
                    });
                })
            }
            // update function
            // pass in geoJSON, must be called inside of d3.json
            function update(json) {
                svg.selectAll("path")
                    .data(json.features)
                    .join( function(enter) {
                        return enter.append("path")
                            .attr("d", path)
                            .style("fill", function(d,i) {
                                var value = values[i, 0]
                                if (value) {
                                    return colourRange(value);
                                } 
                                else
                                {
                                    return "#ccc";
                                }
                            });
                        },
                        function(update) {
                            return update.style("fill", function(d, i) {
                                var value = values[i, 0]
                                if (value) {
                                    return colourRange(value);
                                }
                                else
                                {
                                    return "#ccc"
                                }
                            })
                        }
                    ) 
                };
            // call load function
            Load()
        </script>
    </p>
    <br/>
    <br/>
    <footer style="color:grey"><br/>COS30045 Data Visualization<br/></footer>
</body>
</html>